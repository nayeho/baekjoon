#include <stdio.h>

#define MAX 1000001

// 나머지 개수 누적
// sum % M 값을 인덱스로 갖는 배열
int count[1001];
int array[MAX];

// 전반적인 로직에 관한 설명
// 어떤 구간 [i, j]에서
// M으로 나누어 떨어지는 경우의 수를 구해보자
// 문제에서 주어진 예시에서
// M = 3, 수열은 1, 2, 3, 1, 2이다
// 인덱스        0 1 2 3 4 5
// 누적합        0 1 3 6 7 9
// 누적합(mod 3) 0 1 0 0 1 0
// 이 때, 누적합(mod 3)이 같은 쌍을 선택하면 되는데
// [i, j]구간에서
// (누적합[j] - 누적합[i - 1]) % M == 0 을 만족한다는 것은
// 누적합[j] % M == 누적합[i - 1] % M 과 동치이다.
// 즉, 같은 나머지를 가진 누적합끼리 짝을 이루면 부분합이 M으로 나누어 떨어진다
// 0 : 4개중에 2개 선택 -> 4C2 = 6
// 1 : 2개중에 2개 선택 -> 2C2 = 1
// 총 7개가 된다

// 예를 들어, M이 3이면 나머지가 될 경우의 수는 0, 1, 2로 3가지이다.
// M이 X라면 나머지가 될 경우의 수는 X이고
// 모든 조합(Combination)을 구하는건 어렵다 (시간 초과 날 확률이 있다)
// 따라서, 누적합의 나머지를 인덱스로 갖는 배열 count를 만들고
// 누적합의 현재 나머지를 계산해서 
// 이전 그 나머지의 누적합 개수만큼 총 개수를 증가시켜주면 된다.
// 예를 들어, 인덱스 100정도에서 누적합 % 3이 2라면
// count[2]를 꺼내봤을 때, count[2]가 10이다
// 그럼 인덱스 100하고 나머지 10개랑 매칭하면 부분합이 3으로 나누어 떨어지므로
// 총 결과(result)에 10을 더해주면 된다.


int main(void)
{
    int N, M;
    scanf("%d %d", &N, &M);

    long long sum = 0;
    long long result = 0;

    // 누적합 % M == 0인 구간 포함
    count[0] = 1;

    for (int i = 0; i < N; i++)
    {
        int x;
        scanf("%d", &x);
        // 누적합의 현재 나머지 계산
        sum = (sum + x) % M;

        // 현재까지 sum % M과 같은 나머지를 가진 구간 개수 더하기
        result += count[sum];

        // 해당 나머지 개수 증가
        count[sum]++;
    }

    printf("%lld\n", result);
    return 0;
}